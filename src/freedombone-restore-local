#!/bin/bash
#
# .---.                  .              .
# |                      |              |
# |--- .--. .-.  .-.  .-.|  .-. .--.--. |.-.  .-. .--.  .-.
# |    |   (.-' (.-' (   | (   )|  |  | |   )(   )|  | (.-'
# '    '     --'  --'  -' -  -' '  '   -' -'   -' '   -  --'
#
#                    Freedom in the Cloud
#
# Restore from local storage - typically a USB drive

# License
# =======
#
# Copyright (C) 2015-2016 Bob Mottram <bob@robotics.uk.to>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

PROJECT_NAME='freedombone'
COMPLETION_FILE=$HOME/${PROJECT_NAME}-completed.txt
BACKUP_EXTRA_DIRECTORIES=/root/backup-extra-dirs.csv

# whether to restore everything or just a specific application
RESTORE_APP='all'

export TEXTDOMAIN=${PROJECT_NAME}-restore-local
export TEXTDOMAINDIR="/usr/share/locale"

# include utils which allow function_check, go and drive mount
UTILS_FILES=/usr/share/${PROJECT_NAME}/utils/${PROJECT_NAME}-utils-*
for f in $UTILS_FILES
do
  source $f
done

USB_DRIVE=/dev/sdb1
USB_MOUNT=/mnt/usb

# get default USB from config file
CONFIG_FILE=$HOME/${PROJECT_NAME}.cfg
if [ -f $CONFIG_FILE ]; then
	if grep -q "USB_DRIVE=" $CONFIG_FILE; then
		USB_DRIVE=$(cat $CONFIG_FILE | grep "USB_DRIVE=" | awk -F '=' '{print $2}')
	fi
fi

# get the version of Go being used
GO_VERSION=$(cat /usr/share/${PROJECT_NAME}/utils/${PROJECT_NAME}-utils-go | grep 'GO_VERSION=' | head -n 1 | awk -F '=' '{print $2}')
GVM_HOME=$(cat /usr/share/${PROJECT_NAME}/utils/${PROJECT_NAME}-utils-go | grep 'GVM_HOME=' | head -n 1 | awk -F '=' '{print $2}')

ADMIN_USERNAME=''
ADMIN_NAME=
if [ -f $COMPLETION_FILE ]; then
	ADMIN_USERNAME=$(cat $COMPLETION_FILE | grep "Admin user" | awk -F ':' '{print $2}')
fi

# MariaDB password
DATABASE_PASSWORD=$(cat /root/dbpass)

function check_backup_exists {
	if [ ! -d $USB_MOUNT/backup ]; then
		echo $"No backup directory found on the USB drive."
		set_user_permissions
		backup_unmount_drive
		exit 2
	fi
}

function check_admin_user {
	echo $"Checking that admin user exists"
	if [ ! -d /home/$ADMIN_USERNAME ]; then
		echo $"Username $ADMIN_USERNAME not found. Reinstall ${PROJECT_NAME} with this username."
		set_user_permissions
		backup_unmount_drive
		exit 295
	fi
}

function copy_gpg_keys {
	echo $"Copying GPG keys from admin user to root"
	cp -r /home/$ADMIN_USERNAME/.gnupg /root
}

function restore_directory_from_usb {
	if [ ! -d ${1} ]; then
		mkdir ${1}
	fi
	obnam restore -r $USB_MOUNT/backup/${2} --to ${1}
}

function restore_database {
	RESTORE_SUBDIR="root"

	if [ -d $USB_MOUNT/backup/${1} ]; then
		echo $"Restoring ${1} database"
		restore_directory_from_usb "/root/temp${1}data" "${1}data"
		if [ ! -f /root/temp${1}data/${RESTORE_SUBDIR}/temp${1}data/${1}.sql ]; then
			echo $"Unable to restore ${1} database"
			rm -rf /root/temp${1}data
			set_user_permissions
			backup_unmount_drive
			exit 503
		fi
		mysqlsuccess=$(mysql -u root --password=$DATABASE_PASSWORD ${1} -o < /root/temp${1}data/${RESTORE_SUBDIR}/temp${1}data/${1}.sql)
		if [ ! "$?" = "0" ]; then
			echo "$mysqlsuccess"
			set_user_permissions
			backup_unmount_drive
			exit 964
		fi
		shred -zu /root/temp${1}data/${RESTORE_SUBDIR}/temp${1}data/*
		rm -rf /root/temp${1}data
		echo $"Restoring ${1} installation"
		if [ ! -d /root/temp${1} ]; then
			mkdir /root/temp${1}
		fi
		restore_directory_from_usb "/root/temp${1}" "${1}"
		RESTORE_SUBDIR="var"
		if [ ${2} ]; then
			# special handline of ttrss
			if [[ ${2} == "ttrss" ]]; then
				if [ -d /etc/share/tt-rss ]; then
					if [ -d /root/temp${1}/etc/share/tt-rss ]; then
						rm -rf /etc/share/tt-rss
						mv /root/temp${1}/etc/share/tt-rss /etc/share/
						if [ ! "$?" = "0" ]; then
							set_user_permissions
							backup_unmount_drive
							exit 528
						fi
						if [ -d /etc/letsencrypt/live/${2} ]; then
							ln -s /etc/letsencrypt/live/${2}/privkey.pem /etc/ssl/private/${2}.key
							ln -s /etc/letsencrypt/live/${2}/fullchain.pem /etc/ssl/certs/${2}.pem
						else
							# Ensure that the bundled SSL cert is being used
							if [ -f /etc/ssl/certs/${2}.bundle.crt ]; then
								sed -i "s|${2}.crt|${2}.bundle.crt|g" /etc/nginx/sites-available/${2}
							fi
						fi
					fi
				fi
			fi

			if [ -d /var/www/${2}/htdocs ]; then
				if [ -d /root/temp${1}/${RESTORE_SUBDIR}/www/${2}/htdocs ]; then
					rm -rf /var/www/${2}/htdocs
					mv /root/temp${1}/${RESTORE_SUBDIR}/www/${2}/htdocs /var/www/${2}/
					if [ ! "$?" = "0" ]; then
						set_user_permissions
						backup_unmount_drive
						exit 683
					fi
					if [ -d /etc/letsencrypt/live/${2} ]; then
						ln -s /etc/letsencrypt/live/${2}/privkey.pem /etc/ssl/private/${2}.key
						ln -s /etc/letsencrypt/live/${2}/fullchain.pem /etc/ssl/certs/${2}.pem
					else
						# Ensure that the bundled SSL cert is being used
						if [ -f /etc/ssl/certs/${2}.bundle.crt ]; then
							sed -i "s|${2}.crt|${2}.bundle.crt|g" /etc/nginx/sites-available/${2}
						fi
					fi
				fi
			fi
		fi
	fi
}

function restore_configuration {
	if [[ $RESTORE_APP != 'all' ]]; then
		if [[ $RESTORE_APP != 'configuration' ]]; then
			return
		fi
	fi

	# this restores *.cfg and COMPLETION_FILE
	if [ -d $USB_MOUNT/backup/config ]; then
		echo $"Restoring configuration files"
		temp_restore_dir=/root/tempconfig
		restore_directory_from_usb $temp_restore_dir config

		cp -f $temp_restore_dir/root/${PROJECT_NAME}.cfg $CONFIG_FILE
		if [ ! "$?" = "0" ]; then
			set_user_permissions
			backup_unmount_drive
			rm -rf $temp_restore_dir
			exit 5294
		fi
		if [ -f $CONFIG_FILE ]; then
			# install according to the config file
			freedombone -c $CONFIG_FILE
		fi

		cp -f $temp_restore_dir/root/${PROJECT_NAME}-completed.txt $COMPLETION_FILE
		if [ ! "$?" = "0" ]; then
			set_user_permissions
			backup_unmount_drive
			rm -rf $temp_restore_dir
			exit 6382
		fi

		if [ -f ${temp_restore_dir}${BACKUP_EXTRA_DIRECTORIES} ]; then
			cp -f ${temp_restore_dir}${BACKUP_EXTRA_DIRECTORIES} ${BACKUP_EXTRA_DIRECTORIES}
			if [ ! "$?" = "0" ]; then
				set_user_permissions
				backup_unmount_drive
				rm -rf $temp_restore_dir
				exit 62121
			fi
		fi

		# restore nginx password hashes
		if [ -f $temp_restore_dir/root/htpasswd ]; then
			cp -f $temp_restore_dir/root/htpasswd /etc/nginx/.htpasswd
		fi

		rm -rf $temp_restore_dir
	fi
}

function same_admin_user {
	PREV_ADMIN_USERNAME=$(cat $COMPLETION_FILE | grep "Admin user" | awk -F ':' '{print $2}')
	if [[ "$PREV_ADMIN_USERNAME" != "$ADMIN_USERNAME" ]]; then
		echo $"The admin username has changed from $PREV_ADMIN_USERNAME to $ADMIN_USERNAME. To restore you will first need to install a new ${PROJECT_NAME} system with an initial admin user named $PREV_ADMIN_USERNAME"
		set_user_permissions
		backup_unmount_drive
		exit 73265
	fi
}

function restore_mariadb {
	if [[ $RESTORE_APP != 'all' ]]; then
		if [[ $RESTORE_APP != 'mariadb' ]]; then
			return
		fi
	fi
	if [ -d $USB_MOUNT/backup/mariadb ]; then
		echo $"Restoring mysql settings"
		temp_restore_dir=/root/tempmariadb
		restore_directory_from_usb $temp_restore_dir mariadb
		echo $"Get the MariaDB password from the backup"
		if [ ! -f ${temp_restore_dir}${temp_restore_dir}/db ]; then
			echo $"MariaDB password file not found"
			exit 495
		fi
		BACKUP_MARIADB_PASSWORD=$(cat ${temp_restore_dir}${temp_restore_dir}/db)
		if [[ $BACKUP_MARIADB_PASSWORD != $DATABASE_PASSWORD ]]; then
			echo $"Restore the MariaDB user table"
			mysqlsuccess=$(mysql -u root --password=$DATABASE_PASSWORD mysql -o < ${temp_restore_dir}${temp_restore_dir}/mysql.sql)
			if [ ! "$?" = "0" ]; then
				echo $"Try again using the password obtained from backup"
				mysqlsuccess=$(mysql -u root --password=$BACKUP_MARIADB_PASSWORD mysql -o < ${temp_restore_dir}${temp_restore_dir}/mysql.sql)
			fi
			if [ ! "$?" = "0" ]; then
				echo "$mysqlsuccess"
				set_user_permissions
				backup_unmount_drive
				exit 962
			fi
			echo $"Restarting database"
			service mysql restart
			echo $"Change the MariaDB password to the backup version"
			DATABASE_PASSWORD=$BACKUP_MARIADB_PASSWORD
		fi
		shred -zu ${temp_restore_dir}${temp_restore_dir}/db
		rm -rf $temp_restore_dir

		# Change database password file
		echo "$DATABASE_PASSWORD" > /root/dbpass
		chmod 600 /root/dbpass
	fi
}

function restore_letsencrypt {
	if [[ $RESTORE_APP != 'all' ]]; then
		if [[ $RESTORE_APP != 'letsencrypt' ]]; then
			return
		fi
	fi
	if [ -d $USB_MOUNT/backup/letsencrypt ]; then
		echo $"Restoring Lets Encrypt settings"
		restore_directory_from_usb / letsencrypt
	fi
}

function restore_tor {
	if [[ $RESTORE_APP != 'all' ]]; then
		if [[ $RESTORE_APP != 'tor' ]]; then
			return
		fi
	fi
	if [ -d $USB_MOUNT/backup/tor ]; then
		echo $"Restoring Tor settings"
		restore_directory_from_usb / tor
	fi
}

function restore_mutt_settings {
	if [[ $RESTORE_APP != 'all' ]]; then
		if [[ $RESTORE_APP != 'mutt' ]]; then
			return
		fi
	fi
	if [ -d $USB_MOUNT/backup/mutt ]; then
		for d in $USB_MOUNT/backup/mutt/*/ ; do
			USERNAME=$(echo "$d" | awk -F '/' '{print $6}')
			if [[ $USERNAME != "git" && $USERNAME != "mirrors" && $USERNAME != "sync" ]]; then
				if [ ! -d /home/$USERNAME ]; then
					${PROJECT_NAME}-adduser $USERNAME
				fi
				echo $"Restoring Mutt settings for $USERNAME"
				temp_restore_dir=/root/tempmutt
				restore_directory_from_usb $temp_restore_dir mutt/$USERNAME
				if [ -f $temp_restore_dir/home/$USERNAME/tempbackup/.muttrc ]; then
					cp -f $temp_restore_dir/home/$USERNAME/tempbackup/.muttrc /home/$USERNAME/.muttrc
				fi
				if [ -f $temp_restore_dir/home/$USERNAME/tempbackup/Muttrc ]; then
					cp -f $temp_restore_dir/home/$USERNAME/tempbackup/Muttrc /etc/Muttrc
				fi
				if [ ! "$?" = "0" ]; then
					rm -rf $temp_restore_dir
					set_user_permissions
					backup_unmount_drive
					exit 276
				fi
				rm -rf $temp_restore_dir
			fi
		done
	fi
}

function restore_gpg {
	if [[ $RESTORE_APP != 'all' ]]; then
		if [[ $RESTORE_APP != 'gpg' ]]; then
			return
		fi
	fi
	if [ -d $USB_MOUNT/backup/gnupg ]; then
		for d in $USB_MOUNT/backup/gnupg/*/ ; do
			USERNAME=$(echo "$d" | awk -F '/' '{print $6}')
			if [[ $USERNAME != "git" && $USERNAME != "mirrors" && $USERNAME != "sync" ]]; then
				if [ ! -d /home/$USERNAME ]; then
					${PROJECT_NAME}-adduser $USERNAME
				fi
				echo $"Restoring gnupg settings for $USERNAME"
				temp_restore_dir=/root/tempgnupg
				restore_directory_from_usb $temp_restore_dir gnupg/$USERNAME
				cp -r $temp_restore_dir/home/$USERNAME/.gnupg /home/$USERNAME/
				if [ ! "$?" = "0" ]; then
					rm -rf $temp_restore_dir
					set_user_permissions
					backup_unmount_drive
					exit 276
				fi
				rm -rf $temp_restore_dir
				if [[ "$USERNAME" == "$ADMIN_USERNAME" ]]; then
					cp -r /home/$USERNAME/.gnupg /root
					if [ ! "$?" = "0" ]; then
						set_user_permissions
						backup_unmount_drive
						exit 283
					fi
				fi
			fi
		done
	fi
}

function restore_procmail {
	if [[ $RESTORE_APP != 'all' ]]; then
		if [[ $RESTORE_APP != 'procmail' ]]; then
			return
		fi
	fi
	if [ -d $USB_MOUNT/backup/procmail ]; then
		for d in $USB_MOUNT/backup/procmail/*/ ; do
			USERNAME=$(echo "$d" | awk -F '/' '{print $6}')
			if [[ $USERNAME != "git" && $USERNAME != "mirrors" && $USERNAME != "sync" ]]; then
				if [ ! -d /home/$USERNAME ]; then
					${PROJECT_NAME}-adduser $USERNAME
				fi
				echo $"Restoring procmail settings for $USERNAME"
				temp_restore_dir=/root/tempprocmail
				restore_directory_from_usb $temp_restore_dir procmail/$USERNAME
				cp -f $temp_restore_dir/home/$USERNAME/tempbackup/.procmailrc /home/$USERNAME/
				if [ ! "$?" = "0" ]; then
					rm -rf $temp_restore_dir
					set_user_permissions
					backup_unmount_drive
					exit 276
				fi
				rm -rf $temp_restore_dir
			fi
		done
	fi
}

function restore_spamassassin {
	if [[ $RESTORE_APP != 'all' ]]; then
		if [[ $RESTORE_APP != 'spamassassin' ]]; then
			return
		fi
	fi
	if [ -d $USB_MOUNT/backup/spamassassin ]; then
		for d in $USB_MOUNT/backup/spamassassin/*/ ; do
			USERNAME=$(echo "$d" | awk -F '/' '{print $6}')
			if [[ $USERNAME != "git" && $USERNAME != "mirrors" && $USERNAME != "sync" ]]; then
				if [ -d $USB_MOUNT/backup/spamassassin/$USERNAME ]; then
					if [ ! -d /home/$USERNAME ]; then
						${PROJECT_NAME}-adduser $USERNAME
					fi
					echo $"Restoring spamassassin settings for $USERNAME"
					temp_restore_dir=/root/tempspamassassin
					restore_directory_from_usb $temp_restore_dir spamassassin/$USERNAME
					cp -rf $temp_restore_dir/home/$USERNAME/.spamassassin /home/$USERNAME/
					if [ ! "$?" = "0" ]; then
						rm -rf $temp_restore_dir
						set_user_permissions
						backup_unmount_drive
						exit 276
					fi
					rm -rf $temp_restore_dir
				fi
			fi
		done
	fi
}

function restore_admin_readme {
	if [[ $RESTORE_APP != 'all' ]]; then
		if [[ $RESTORE_APP != 'readme' ]]; then
			return
		fi
	fi
	if [ -d $USB_MOUNT/backup/readme ]; then
		echo $"Restoring admin user README"

		# Make a backup of the original README file
		# incase old passwords need to be used
		if [ -f /home/$ADMIN_USERNAME/README ]; then
			if [ ! -f /home/$ADMIN_USERNAME/README_original ]; then
				cp /home/$ADMIN_USERNAME/README /home/$ADMIN_USERNAME/README_original
			fi
		fi

		temp_restore_dir=/root/tempreadme
		restore_directory_from_usb $temp_restore_dir readme
		cp -f $temp_restore_dir/home/$ADMIN_USERNAME/tempbackup/README /home/$ADMIN_USERNAME/
		if [ ! "$?" = "0" ]; then
			rm -rf $temp_restore_dir
			set_user_permissions
			backup_unmount_drive
			exit 276
		fi
		rm -rf $temp_restore_dir
	fi
}

function restore_user_ssh_keys {
	if [[ $RESTORE_APP != 'all' ]]; then
		if [[ $RESTORE_APP != 'ssh' ]]; then
			return
		fi
	fi
	if [ -d $USB_MOUNT/backup/ssh ]; then
		for d in $USB_MOUNT/backup/ssh/*/ ; do
			USERNAME=$(echo "$d" | awk -F '/' '{print $6}')
			if [[ $USERNAME != "git" && $USERNAME != "mirrors" && $USERNAME != "sync" ]]; then
				if [ ! -d /home/$USERNAME ]; then
					${PROJECT_NAME}-adduser $USERNAME
				fi
				echo $"Restoring ssh keys for $USERNAME"
				temp_restore_dir=/root/tempssh
				restore_directory_from_usb $temp_restore_dir ssh/$USERNAME
				cp -r $temp_restore_dir/home/$USERNAME/.ssh /home/$USERNAME/
				if [ ! "$?" = "0" ]; then
					rm -rf $temp_restore_dir
					set_user_permissions
					backup_unmount_drive
					exit 664
				fi
				rm -rf $temp_restore_dir
			fi
		done
	fi
}

function restore_user_config {
	if [[ $RESTORE_APP != 'all' ]]; then
		if [[ $RESTORE_APP != 'userconfig' ]]; then
			return
		fi
	fi
	if [ -d $USB_MOUNT/backup/config ]; then
		for d in $USB_MOUNT/backup/config/*/ ; do
			USERNAME=$(echo "$d" | awk -F '/' '{print $6}')
			if [[ $USERNAME != "git" && $USERNAME != "mirrors" && $USERNAME != "sync" ]]; then
				if [ ! -d /home/$USERNAME ]; then
					${PROJECT_NAME}-adduser $USERNAME
				fi
				echo $"Restoring config files for $USERNAME"
				temp_restore_dir=/root/tempconfig
				restore_directory_from_usb $temp_restore_dir config/$USERNAME
				cp -r $temp_restore_dir/home/$USERNAME/.config /home/$USERNAME/
				if [ ! "$?" = "0" ]; then
					rm -rf $temp_restore_dir
					set_user_permissions
					backup_unmount_drive
					exit 664
				fi
				rm -rf $temp_restore_dir
			fi
		done
	fi
}

function gpg_pubkey_from_email {
	key_owner_username=$1
	key_email_address=$2
	key_id=
	if [[ $key_owner_username != "root" ]]; then
		key_id=$(su -c "gpg --list-keys $key_email_address | grep 'pub '" - $key_owner_username | awk -F ' ' '{print $2}' | awk -F '/' '{print $2}')
	else
		key_id=$(gpg --list-keys $key_email_address | grep 'pub ' | awk -F ' ' '{print $2}' | awk -F '/' '{print $2}')
	fi
	echo $key_id
}

function restore_user_monkeysphere {
	if [[ $RESTORE_APP != 'all' ]]; then
		if [[ $RESTORE_APP != 'usermonkeysphere' ]]; then
			return
		fi
	fi
	if [ -d $USB_MOUNT/backup/monkeysphere ]; then
		for d in $USB_MOUNT/backup/monkeysphere/*/ ; do
			USERNAME=$(echo "$d" | awk -F '/' '{print $6}')
			if [[ $USERNAME != "git" && $USERNAME != "mirrors" && $USERNAME != "sync" ]]; then
				if [ ! -d /home/$USERNAME ]; then
					${PROJECT_NAME}-adduser $USERNAME
				fi
				echo $"Restoring monkeysphere ids for $USERNAME"
				temp_restore_dir=/root/tempmonkeysphere
				restore_directory_from_usb $temp_restore_dir monkeysphere/$USERNAME
				cp -r $temp_restore_dir/home/$USERNAME/.monkeysphere /home/$USERNAME/
				if [ ! "$?" = "0" ]; then
					rm -rf $temp_restore_dir
					set_user_permissions
					backup_unmount_drive
					exit 664
				fi
				rm -rf $temp_restore_dir
			fi
		done

		# The admin user is the identity certifier
		MY_EMAIL_ADDRESS="${ADMIN_USERNAME}@${HOSTNAME}"
		if grep -q "MY_EMAIL_ADDRESS" $CONFIG_FILE; then
			MY_EMAIL_ADDRESS=$(grep "MY_EMAIL_ADDRESS" $CONFIG_FILE | awk -F '=' '{print $2}')
		fi
		MY_GPG_PUBLIC_KEY_ID=$(gpg_pubkey_from_email "$ADMIN_USERNAME" "$MY_EMAIL_ADDRESS")
		fpr=$(gpg --with-colons --fingerprint $MY_GPG_PUBLIC_KEY_ID | grep fpr | head -n 1 | awk -F ':' '{print $10}')
		monkeysphere-authentication add-identity-certifier $fpr
		monkeysphere-authentication update-users
	fi
}

function restore_user_fin {
	if [[ $RESTORE_APP != 'all' ]]; then
		if [[ $RESTORE_APP != 'userfin' ]]; then
			return
		fi
	fi
	if [ -d $USB_MOUNT/backup/fin ]; then
		for d in $USB_MOUNT/backup/fin/*/ ; do
			USERNAME=$(echo "$d" | awk -F '/' '{print $6}')
			if [[ $USERNAME != "git" && $USERNAME != "mirrors" && $USERNAME != "sync" ]]; then
				if [ ! -d /home/$USERNAME ]; then
					${PROJECT_NAME}-adduser $USERNAME
				fi
				echo $"Restoring fin files for $USERNAME"
				temp_restore_dir=/root/tempfin
				restore_directory_from_usb $temp_restore_dir fin/$USERNAME
				cp -r $temp_restore_dir/home/$USERNAME/.fin /home/$USERNAME/
				if [ ! "$?" = "0" ]; then
					rm -rf $temp_restore_dir
					set_user_permissions
					backup_unmount_drive
					exit 664
				fi
				rm -rf $temp_restore_dir
			fi
		done
	fi
}

function restore_user_local {
	if [[ $RESTORE_APP != 'all' ]]; then
		if [[ $RESTORE_APP != 'userlocal' ]]; then
			return
		fi
	fi
	if [ -d $USB_MOUNT/backup/local ]; then
		for d in $USB_MOUNT/backup/local/*/ ; do
			USERNAME=$(echo "$d" | awk -F '/' '{print $6}')
			if [[ $USERNAME != "git" && $USERNAME != "mirrors" && $USERNAME != "sync" ]]; then
				if [ ! -d /home/$USERNAME ]; then
					${PROJECT_NAME}-adduser $USERNAME
				fi
				echo $"Restoring local files for $USERNAME"
				temp_restore_dir=/root/templocal
				restore_directory_from_usb $temp_restore_dir local/$USERNAME
				cp -r $temp_restore_dir/home/$USERNAME/.local /home/$USERNAME/
				if [ ! "$?" = "0" ]; then
					rm -rf $temp_restore_dir
					set_user_permissions
					backup_unmount_drive
					exit 664
				fi
				rm -rf $temp_restore_dir
			fi
		done
	fi
}

function restore_certs {
	if [[ $RESTORE_APP != 'all' ]]; then
		if [[ $RESTORE_APP != 'certs' ]]; then
			return
		fi
	fi
	if [ -d $USB_MOUNT/backup/ssl ]; then
		echo $"Restoring certificates"
		mkdir /root/tempssl
		restore_directory_from_usb /root/tempssl ssl
		cp -r /root/tempssl/etc/ssl/* /etc/ssl
		if [ ! "$?" = "0" ]; then
			set_user_permissions
			backup_unmount_drive
			exit 276
		fi
		rm -rf /root/tempssl

		# restore ownership
		if [ -f /etc/ssl/private/xmpp.key ]; then
			chown prosody:prosody /etc/ssl/private/xmpp.key
			chown prosody:prosody /etc/ssl/certs/xmpp.*
		fi
		if [ -d /etc/dovecot ]; then
			chown root:dovecot /etc/ssl/private/dovecot.*
			chown root:dovecot /etc/ssl/certs/dovecot.*
		fi
		if [ -f /etc/ssl/private/exim.key ]; then
			cp /etc/ssl/private/exim.key /etc/exim4
			cp /etc/ssl/certs/exim.crt /etc/exim4
			cp /etc/ssl/certs/exim.dhparam /etc/exim4
			chown root:Debian-exim /etc/exim4/exim.key /etc/exim4/exim.crt /etc/exim4/exim.dhparam
			chmod 640 /etc/exim4/exim.key /etc/exim4/exim.crt /etc/exim4/exim.dhparam
		fi
		if [ -f /etc/ssl/private/mumble.key ]; then
			if [ -d /var/lib/mumble-server ]; then
				cp /etc/ssl/certs/mumble.* /var/lib/mumble-server
				cp /etc/ssl/private/mumble.key /var/lib/mumble-server
				chown -R mumble-server:mumble-server /var/lib/mumble-server
			fi
		fi
	fi
}

function restore_personal_settings {
	if [[ $RESTORE_APP != 'all' ]]; then
		if [[ $RESTORE_APP != 'personal' ]]; then
			return
		fi
	fi
	if [ -d $USB_MOUNT/backup/personal ]; then
		for d in $USB_MOUNT/backup/personal/*/ ; do
			USERNAME=$(echo "$d" | awk -F '/' '{print $6}')
			if [[ $USERNAME != "git" && $USERNAME != "mirrors" && $USERNAME != "sync" ]]; then
				if [ -d $USB_MOUNT/backup/personal/$USERNAME ]; then
					if [ ! -d /home/$USERNAME ]; then
						${PROJECT_NAME}-adduser $USERNAME
					fi
					echo $"Restoring personal settings for $USERNAME"
					temp_restore_dir=/root/temppersonal
					restore_directory_from_usb $temp_restore_dir personal/$USERNAME
					if [ -d /home/$USERNAME/personal ]; then
						rm -rf /home/$USERNAME/personal
					fi
					mv $temp_restore_dir/home/$USERNAME/personal /home/$USERNAME
					if [ ! "$?" = "0" ]; then
						set_user_permissions
						backup_unmount_drive
						exit 184
					fi
					rm -rf $temp_restore_dir
				fi
			fi
		done
	fi
}

function restore_mailing_list {
	if [[ $RESTORE_APP != 'all' ]]; then
		if [[ $RESTORE_APP != 'mailinglist' ]]; then
			return
		fi
	fi
	if [ -d /var/spool/mlmmj ]; then
		echo $"Restoring public mailing list"
		temp_restore_dir=/root/tempmailinglist
		restore_directory_from_usb $temp_restore_dir mailinglist
		cp -r $temp_restore_dir/root/spool/mlmmj/* /var/spool/mlmmj
		if [ ! "$?" = "0" ]; then
			set_user_permissions
			backup_unmount_drive
			exit 526
		fi
		rm -rf $temp_restore_dir
	fi
}

function restore_email {
	if [[ $RESTORE_APP != 'all' ]]; then
		if [[ $RESTORE_APP != 'email' ]]; then
			return
		fi
	fi
	if [ -d $USB_MOUNT/backup/mail ]; then
		for d in $USB_MOUNT/backup/mail/*/ ; do
			USERNAME=$(echo "$d" | awk -F '/' '{print $6}')
			if [[ $USERNAME != "git" && $USERNAME != "mirrors" && $USERNAME != "sync" ]]; then
				if [ ! -d /home/$USERNAME ]; then
					${PROJECT_NAME}-adduser $USERNAME
				fi
				echo $"Restoring emails for $USERNAME"
				temp_restore_dir=/root/tempmail
				restore_directory_from_usb $temp_restore_dir mail/$USERNAME
				if [ ! -d /home/$USERNAME/Maildir ]; then
					mkdir /home/$USERNAME/Maildir
				fi
				tar -xzvf $temp_restore_dir/root/tempbackupemail/$USERNAME/maildir.tar.gz -C /
				if [ ! "$?" = "0" ]; then
					set_user_permissions
					backup_unmount_drive
					exit 927
				fi
				rm -rf $temp_restore_dir
			fi
		done
	fi
}

function get_restore_app {
	if [ ${1} ]; then
		if [ ! -d /home/${1} ]; then
			RESTORE_APP=${1}
			echo $"Restore $RESTORE_APP"
		fi
	fi
}

function restore_apps {
	FILES=/usr/share/${PROJECT_NAME}/apps/${PROJECT_NAME}-app-*

	APPS_COMPLETED=()

	# for all the app scripts
	for filename in $FILES
	do
		app_name=$(echo "${filename}" | awk -F '-app-' '{print $2}')
		if [[ $RESTORE_APP == 'all' || $RESTORE_APP == "${app_name}"  ]]; then
			if [[ $(item_in_array ${app_name} ${APPS_COMPLETED[@]}) != 0 ]]; then
				function_check app_is_installed
				if [[ "$(app_is_installed $a)" == "1" ]]; then
					APPS_COMPLETED+=("${app_name}")
					function_check restore_local_${app_name}
					restore_local_${app_name}
				fi
			fi
		fi
	done
}

get_restore_app ${2}
backup_mount_drive ${1} ${ADMIN_USERNAME} ${2}
check_backup_exists
check_admin_user
copy_gpg_keys
restore_configuration
same_admin_user
restore_mariadb
restore_letsencrypt
restore_tor
restore_mutt_settings
restore_gpg
restore_procmail
restore_spamassassin
restore_admin_readme
restore_user_ssh_keys
restore_user_config
restore_user_monkeysphere
restore_user_fin
restore_user_local
restore_certs
restore_personal_settings
restore_mailing_list
restore_email
restore_apps
set_user_permissions
backup_unmount_drive

echo $"Restore from USB drive is complete. You can now unplug it."

exit 0
